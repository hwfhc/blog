# TCP学习笔记

## 一、介绍  
tcp协议是传输层协议的一种，拥有可靠传输、拥塞控制、流控制等功能。   
是面向连接的，目前得到广泛的应用。

## 二、报文格式   
![](/articles/TCP学习笔记/segment_structure.png)

## 三、可靠传输
由于IP协议是不可靠的，数据包可能由于缓冲区已满而被丢弃，或者抵达顺序不同。因此我们需要可靠传输服务。   
保证进程读取到的数据流无错误，没有空项，没有重复项，按照顺序。也就是和传输的数据流完全一样。   

### seq与ack
连接两端均有各自的seq与ack   

seq代表当前包的顺序号，   
ack目前已收包的顺序号，例如ack为100，则前100字节的数据均已接收到。   
另外如果收到了前100字节、与102字节，此时101字节未收到，则102字节会被缓存，不会发出ack101   

另外如果收到的包的seq小于ack，则会发送当前ack包，表示目前已接收到的数据是多少   

### 计时器
计时器到期时触发重传，根据seq。同时将计时器周期乘2，初始时间使用某种方法估计    

计时器用于判断丢包

### 冗余ACK
三次ACK也是丢包，那么为啥是三次ACK呢？   
因为两次ACK很大概率是因为乱序。   
而如果发生了丢包，则必定发生三次ACK（当然也有可能是因为乱序，不过概率相对丢包较低）。   
具体见参考资料

### 快速重传
只靠计时器来触发丢包未免周期太长了。   

如果发送者收到同一个ACK三次，那么则认为这个segment后端segment丢失了。重新传输这些segment，在segment的计时器到期前   

### 重传机制   
实际上TCP的重传机制是Go-Back-N和SR的混合体   
在GBN的基础上，会缓存收到的但未按顺序抵达的，并且只会重传没有接收到的包，而不是全部重传。   

### Go-Back-N    
事实上图中浅蓝色的部分就是已经发送但还没有ack的包。   
当触发重传时，Go-Back-N会将所有浅蓝色的包重新发送一遍。   
显然收到ack包时base的值会+1，发送一个新的包时nextseqnum会+1

![1](/articles/TCP学习笔记/Go-Back-N.png)

#### Selective Repeat
SR会将不按序到达的包缓存起来，并且所有已发送包均会计时，如果超时则会重发。   
同时由于缓存的存在，我们显然需要一个window进行限制（与流控制相同）   

![](/articles/TCP学习笔记/SR.png)

## 四、流控制
由于一个seq包发过来之后如果不是按照顺序，则会暂时留在缓存中，那么要是不按顺序的seq包多了就会爆缓存。于是就有了流控制，保证发送者不会爆掉接收者的缓存。综合考虑接收者本地读取速率和网络传输速率。    

也就是说控制了正在传输的seq包的数量。   

通过发送者维护一个变量 receive window 实现，用于告诉发送者 接收者有多少可用的缓存空间。同时由于TCP是双向的，连接两端都会维护一个对方的window。即rwnd。   

![](/articles/TCP学习笔记/rwnd.png)   

rwnd是动态的，初始值即为RcvBuffer   
```rwnd = RcvBuffer – [LastByteRcvd – LastByteRead]```    

主机B告诉主机A有多少空闲缓存空间可用（将这个值放在每个发给A的segment中）。而A维护两个变量，LastByteSent与LastByteAcked。这两个变量的差值可以理解为正在传输中的seq包，显然有：   
```LastByteSent – LastByteAcked ≤ rwnd```   

## 五、拥塞控制 
如果说流控制是为了让接收数据的终端不被爆缓存，那么拥塞控制就是为了保证尽可能利用网络空间，而不让网络过于堵塞。换句话说就是让链路中有适当数量的包，既充分利用链路，同时也不触发丢包。保证网络的高效与畅通。   

在这里引入了一个新的窗口congestion window，即cwnd。   
他同样限制了正在传输的seq包的数量。限制规则如下：   
```LastByteSent – LastByteAcked ≤ min{cwnd, rwnd}```

同时我们遵循下面三个原则来判断拥塞：
  1. segment丢失意味着拥塞，我们应该降低发包速率
  2. 收到一个ack包意味着网络畅通，我们应该提高发包速率
  3. 通过收包和丢包来不断动态变化发包速率

### 慢启动
ssthresh（slow start threhold）： 慢启动峰值线   

TCP连接刚刚建立时，cwnd的值被设置为一个很小的值（1 MSS，一般为512或者536）。在慢启动状态下每次收到ACK包，cwnd的值都会增加1 MSS，    

注意是每个ACK包！   
传输速率是指数级增长，也就是说在每个RTT内，cwnd翻倍了。   
所以慢启动其实并不慢。  

#### 慢启动在三种以下情况下会中止:
1. **计时器丢包：**   
如果计时器显示出现了一个丢包，则将cwnd设置为1，并且重新开始慢启动。它还将ssthresh的值设置为检测到拥塞时（即计时器到期时），拥塞窗口值的cwnd的一半。    
那么问题来了，为啥是cwnd / 2？   
显然是因为计时器判定丢包是有一个延迟的，距离丢失的包发送的时候已经过去了 RTT ，而在这段时间内cwnd已经翻倍了，所以要设置成现在cwnd的一半。

2. **超过ssthresh**：   
ssthresh代表着发包速率的红线，红线后是随时可能发生拥塞的世界。   
而我们现在已经跨过了红线了，向前的每一步都危机四伏，需要小心谨慎地增长发包速率。   
因此我们终止了慢启动状态，转而进入拥塞避免状态。   

3. **冗余ACK：**   
好的我们收到了三个重复的ACK，这意味着有一个数据包在网络传输中迷失了方向。   
不过没关系，我们把这个包重新传输一次就行了。   
首先将ssthresh设置为cwnd/2，将cwnd减半并增加3 MSS。   
增加的3MSS代表三个冗余ACK，由于他们被成功收到了所以可以增加cwnd。   
然后TCP执行快速重传并进入快速恢复状态。

### 拥塞规避
这个模式下传输速率增长更加谨慎，因为拥堵随时可能发生，转角遇到爱。   

因此我们采用一种更怂的方法来增长cwnd，每个RTT内cwnd增加1 MSS，而不是慢启动中的翻倍。具体实现为每个ACK包抵达时cwnd增加MSS*(MSS/cwnd)。 

**拥塞规避在以下两种情况下中止**：   
1. 计时器丢包：   
好的我们踩雷了，拥塞发生了，现在能做的就是设置新的拥塞红线，并且重新启动。   
ssthresh值被修改为cwnd / 2，然后将cwnd设为1 MSS。并且进入慢启动状态   

2. 冗余ACK：ssthresh设置为cwnd的一半，将cwnd减半并增加3MSS。并且进入快速恢复状态

#### 快速恢复  
旨在快速恢复丢失的包，即收到三次A重复ACK之后的包

收到重复的ACK包（导致进入快速恢复状态的丢失segment）则cwnd增加1MSS。  

1. 当ACK到达丢失的段时，TCP在放缩cwnd后进入拥塞避免状态。  
2. 如果发生超时事件，在执行与慢启动和拥塞避免相同的操作后，快速恢复转换为慢启动状态：cwnd的值设置为1 MSS，并且ssthresh的值设置为发生丢包时的cwnd。

![](/articles/TCP学习笔记/FSM.png)

## 六、连接管理
### 建立连接
三向交握    
+ 客户机向服务器发送 TCP SYN 报文段   
指定初始序号   
没有数据   

+ 服务器收到 SYN 报文段, 用 SYNACK 报文段回复   
服务器为该连接分配缓冲区和变量   
指定服务器初始序号   

+ 客户机接收到 SYNACK, 分配缓冲，用 ACK 报文段回复,可能包含数
据。   

#### 断开连接   
四次发包，假如发送者想要关闭连接   
+ 发送者发包，FIN字段为1
+ 接收者发包，ACK字段为1
+ 发送者收到含ACK字段的报文，进行一些处理关闭连接
+ 接收者发包，FIN字段为1
+ 发送者发包，ACK字段为1
+ 接收者收到含ACK字段的报文，进行一些处理关闭连接

### 七、总结

### 参考资料：
+ TCP拥塞控制：                                                                                                                                                                                                                                                                                                                                                                                          https://www.zhihu.com/question/58517416/answer/158142955 
+ TCP重传：    
https://stackoverflow.com/questions/12956685/what-are-the-retransmission-rules-for-tcp
+ 冗余ACK为什么是3次:
https://www.zhihu.com/question/21789252/answer/110640581
+ 拥塞规避RFC:   
https://tools.ietf.org/html/rfc2001