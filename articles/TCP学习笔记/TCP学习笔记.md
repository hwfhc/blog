## TCP学习笔记

### 一、介绍  
tcp协议是传输层协议的一种，拥有可靠传输、拥塞控制、流控制等功能。   
是面向连接的，目前得到广泛的应用。

### 二、报文格式   
![](/articles/TCP学习笔记/segment structure.png)

### 三、可靠传输
由于IP协议是不可靠的，数据包可能由于缓冲区已满而被丢弃，或者抵达顺序不同。因此我们需要可靠传输服务。   
保证进程读取到的数据流无错误，没有空项，没有重复项，按照顺序。也就是和传输的数据流完全一样。   

#### seq与ack
连接两端均有各自的seq与ack   

seq代表当前包的顺序号，   
ack目前已收包的顺序号，例如ack为100，则前100字节的数据均已接收到。   
另外如果收到了前100字节、与102字节，此时101字节未收到，则102字节会被缓存，不会发出ack101   

另外如果收到的包的seq小于ack，则会发送当前ack包，表示目前已接收到的数据是多少   

#### 计时器
计时器到期时触发重传，根据seq。同时将计时器周期乘2，初始时间使用某种方法估计    

计时器用于判断丢包

#### 快速重传
只靠计时器来触发丢包未免周期太长了。   

如果发送者收到同一个ACK三次，那么则认为这个segment后端segment丢失了。重新传输这些segment，在segment的计时器到期前   

#### 重传机制   
实际上TCP的重传机制是Go-Back-N和SR的混合体   
在GBN的基础上，会缓存收到的但未按顺序抵达的，并且只会重传没有接收到的包，而不是全部重传。   

#### Go-Back-N    
事实上图中浅蓝色的部分就是已经发送但还没有ack的包。   
当触发重传时，Go-Back-N会将所有浅蓝色的包重新发送一遍。   
显然收到ack包时base的值会+1，发送一个新的包时nextseqnum会+1

![1](/articles/TCP学习笔记/Go-Back-N.png)

#### Selective Repeat
SR会将不按序到达的包缓存起来，并且所有已发送包均会计时，如果超时则会重发。   
![](/articles/TCP学习笔记/SR.png)

### 四、流控制
由于一个seq包发过来之后如果不是按照顺序，则会暂时留在缓存中，那么要是不按顺序的seq包多了就会爆缓存。于是就有了流控制，保证发送者不会爆掉接收者的缓存。综合考虑接收者本地读取速率和网络传输速率。    

也就是说控制了正在传输的seq包的数量。   

通过发送者维护一个变量 receive window 实现，用于告诉发送者 接收者有多少可用的缓存空间。同时由于TCP是双向的，连接两端都会维护一个对方的window。即rwnd。   

![](/articles/TCP学习笔记/rwnd.png)   

rwnd是动态的，初始值即为RcvBuffer   
```rwnd = RcvBuffer – [LastByteRcvd – LastByteRead]```    

主机B告诉主机A有多少空闲缓存空间可用（将这个值放在每个发给A的segment中）。而A维护两个变量，LastByteSent与LastByteAcked。这两个变量的差值可以理解为正在传输中的seq包，显然有：   
```LastByteSent – LastByteAcked ≤ rwnd```   

### 五、拥塞控制 
如果说流控制是为了让接收数据的终端不被爆缓存，那么拥塞控制就是为了保证尽可能利用网络空间，而不让网络过于堵塞。换句话说就是让链路中有适当数量的包，既充分利用链路，同时也不触发丢包。你好我好大家好。   

在这里我们引入一个新的窗口，congestion window 即cwnd，他同样限制了正在传输的seq包的数量。我们有：   
```LastByteSent – LastByteAcked ≤ min{cwnd, rwnd}```

同时我们遵循下面三个原则来判断拥塞：
  1. segment丢失意味着拥塞：我们应该降低发包速率
  2. 收到一个ack包意味着网络畅通：我们应该提高发包速率
  3. 带宽探测：我们通过收到包和丢包来不断动态变化发包速率

#### 慢启动
ssthresh（slow start threhold）： 慢启动峰值线   

TCP连接刚刚建立时，cwnd的值被设置为一个很小的值1MSS。在慢启动状态下每次收到ACK包，cwnd的值都会增加1MSS，    

注意是每个ACK包！事实上整个传输速率是指数级增长，也就是说在每个RTT内，cwnd翻倍了。   
所以慢启动其实并不慢。  

#### 慢启动中止
1. 如果计时器显示出现了一个丢包，则将cwnd设置为1，并且重新开始慢启动。它还将第二个状态变量ssthresh（简写为“慢启动阈值”）的值设置为检测到拥塞时拥塞窗口值的cwnd / 2的一半。  

2. 慢启动可能结束的第二种方式与ssthresh的值直接相关。 由于ssthresh是上次检测到拥塞时cwnd值的一半，因此当cwnd达到或超过ssthresh的值时，可能会稍微鲁莽一点。 因此，当cwnd的值等于ssthresh时，慢启动结束并且TCP转换到拥塞避免模式。

3. 慢启动可以结束的最后一种方式是，如果检测到三个重复的ACK，ssthresh设置为cwnd的一半，将cwnd减半并增加3MSS。TCP执行快速重传并进入快速恢复状态。

#### 拥塞规避
这个模式下传输速率增长更加谨慎，因为拥堵随时可能发生，转角遇到爱。   

增长：  
因此我们采用一种更怂的方法来增长cwnd，每个RTT内cwnd增加1 MSS，而不是慢启动中的翻倍。具体实现为每个ack包抵达时cwnd增加MSS*(MSS/cwnd)。 

中止：   
当计时器丢包触发时：ssthresh值被修改为cwnd的一半，同时cwnd变为1MSS。并且进入慢启动状态   
当三次ACK丢包触发时：ssthresh设置为cwnd的一半，将cwnd减半并增加3MSS。并且进入快速恢复状态

#### 快速恢复  
旨在快速恢复丢失的包，即收到三次A重复ACK之后的包

收到重复的ACK包（导致进入快速恢复状态的丢失segment）则cwnd增加1MSS。  

1. 当ACK到达丢失的段时，TCP在放缩cwnd后进入拥塞避免状态。  
2. 如果发生超时事件，在执行与慢启动和拥塞避免相同的操作后，快速恢复转换为慢启动状态：cwnd的值设置为1 MSS，并且ssthresh的值设置为发生丢包时的cwnd。

![](/articles/TCP学习笔记/FSM.png)

### 六、连接管理
#### 建立连接
三向交握    
+ 客户机向服务器发送 TCP SYN 报文段   
指定初始序号   
没有数据   

+ 服务器收到 SYN 报文段, 用 SYNACK 报文段回复   
服务器为该连接分配缓冲区和变量   
指定服务器初始序号   

+ 客户机接收到 SYNACK, 分配缓冲，用 ACK 报文段回复,可能包含数
据。   

#### 断开连接   
四次发包，假如发送者想要关闭连接   
+ 发送者发包，FIN字段为1
+ 接收者发包，ACK字段为1
+ 发送者收到含ACK字段的报文，进行一些处理关闭连接
+ 接收者发包，FIN字段为1
+ 发送者发包，ACK字段为1
+ 接收者收到含ACK字段的报文，进行一些处理关闭连接

### 七、总结

### 参考资料：
TCP拥塞控制：                                                                                                                                                                                                                                                                                                                                                                                          https://www.zhihu.com/question/58517416/answer/158142955 
  TCP重传：    
https://stackoverflow.com/questions/12956685/what-are-the-retransmission-rules-for-tcp